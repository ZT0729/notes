# C++

## 1 C++初始

### 1.1 第一个C++程序

编写一个C++程序总共分为4个步骤

* 创建项目
* 创建文件
* 编写代码
* 运行程序

#### 1.1.1 创建项目

Visual Studio是我们用来编写C++程序的主要工具



代码

```c++
#include <iostream>
using namespace std;

int main()
{
	cout << "helle WORLD" << endl;

	system("pause");

	return 0;
}
```



运行结果

![image-20220816192335510](C:\Users\48228\AppData\Roaming\Typora\typora-user-images\image-20220816192335510.png)



### 1.2 注释

**作用**：在代码中加一些说明和解释，方便自己或其他程序员阅读代码

**两种格式**

 	1. **单行注释**：`// 描述信息`
 	 * 通常放在一行代码的上方，或者一条语句的末尾

​	2. **多行注释**：`/*  */`

> 提示：编译器在编译代码时，会忽略注释的代码



### 1.3 变量

**作用**：给一段指定的内存空间起名，方便操作这段内存

**语法**：`数据类型 变量名 = 初始值；`

**示例**

```c++
#include <iostream>
using namespace std;

int main1()
{
	//变量的定义
	//语法：数据类型 变量名 = 初始值
	
	int a = 10；
	
	cout << "helle WORLD" << endl;

	system("pause");

	return 0;
}
```

**变量存在的意义**：方便我们管理内存控件

### 1.4 常量

**作用**：用于记录程序中不可更改的数据

C++定义常量两种方式

1. **#define** 宏常量：`#define 常量名 常量值`
   * 通常在文件上方定义，表示一个常量

2. **const** 修饰的变量 `const 数据类型 常量名 = 常量值`
   * 通常在变量定义前加关键字，修饰该变量位常量，不可修改。



**示例**

```
#define day 7

int main()
{
	//变量的定义
	//语法：数据类型 变量名 = 初始值
	//day = 8; //报错，宏常量不可以修改
	cout << "一周一共有" << day << "天" << endl;

	//2、const修饰的变量
	const int month = 12;
	//month = 15;   //错误，const修饰的变量称为常量

	cout << "一年共有：" << month << "个月份" << endl;

	int a = 10;
	
	cout << "helle WORLD" << endl;

	system("pause");

	return 0;
}
```

### 1.5 关键字

**作用**：关键字是C++中预先保留的单词（标识符）

* **在定义变量或者时，不要用关键字



C++关键字如下：



`提示：在给变量或常量起名称时候，不要用C++的关键字，否者会产生歧义`

### 1.6 标识符命名规则

**作用**：C++规定给标识符（变量、常量）命名时，有一套自己的规则

* 表示标识符不能是关键字
* 标识符只能由字母、数字、下划线组成
* 第一个字符必须为字母或下划线
* 标识符中的字母区分大小写

> 建议：给标识符命名时，争取做到见名知其意的效果方便自己和他人阅读

## 2 数据类型

C++规定在创建一个变量或者常量时，必须要指出相应的数据类型，否则无法给变量分配内存

**数据类型存在意义:**给变量分配合适的内存空间

### 2.1 整形

**作用**：整型变量表示的是整型类型的数据

C++中能够表示整型的类型有以下方式，**区别在于所占内存大小不同**：



| 数据类型              | 占用空间                                            | 取值范围         |
| --------------------- | --------------------------------------------------- | ---------------- |
| short（短整型）       | 2字节                                               | （-2^15~2^15-1） |
| int（整型）           | 4字节                                               | （-2^31~2^31-1） |
| long（长整型）        | Windows为4字节，Linux为4字节（32位），8字节（64为） | （-2^31~2^31-1） |
| long long（长长整型） | 8字节                                               | （-2^63~2^63-1） |

### 2.2 sizeof关键字

**作用**：利用sizeof关键字可以统计数据类型所占内存大小

**语法**：` sizeof( 数据类型 / 变量 )` 

**示例**：

```c++
int main()
{

	cout << "short 类型所占空间为： " << sizeof(short) << endl;

	cout << "int 类型所占空间为： " << sizeof(int) << endl;

	cout << "long 类型所占空间为： " << sizeof(long) << endl;

	cout << "long long 类型所占空间为： " << sizeof(long long) << endl;

	system("pause");

	return 0;
}
```



### 2.3 实型（浮点型）

**作用**：用于表示小数

浮点型变量分为两种：

1. 单精度 float
2. 双精度 double

两者的**区别**在于表示的有效数字范围不同

| 数据类型 | 占用空间 | 有效数字范围    |
| -------- | -------- | --------------- |
| float    | 4字节    | 7位有效数字     |
| double   | 8字节    | 15~16位有效数字 |



**示例**：

```c++
#include<iostream>
using namespace std;

int main()
{
	//1、单精度 float
	//2、双精度 double

	float f1 = 3.14f; // 在单精度后面多家个f，让它知道这是单精度，否则默认双精度。

	cout << "f1 = "<< f1 << endl;
	double d1 = 3.14;

	cout << "d1 = "<< d1 << endl;
	//默认情况下 输出一个小数 会显示出6位有效数字

	//统计 float 和 double 占用内存空间
	cout << "float 所占用空间为：" << sizeof(float) << endl; 
	cout << "double 所占用空间为：" << sizeof(double) << endl;

	//科学计数法
	float f2 = 3e2;  //3 * 10 ^ 2
	cout << "3e2= "<< f2 << endl;
	
	float f3 = 3e-2;  //3 * 0.1 ^ 2
	cout << "3e-2= "<< f3<< endl;

	system("pause");
	return 0;
}
```

### 2.4 字符型

**作用**：字符型变量用于显示单个字符

**语法**：char ch = `a`;

> 注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号
>
> 注意2：单引号内只能有一个字符，不可以是字符串



* C和C++中字符型变量只占用1个字节
* 字符型变量并不是把字符本身放在内存中存储，而是将对应的ASCII编码放入到存储单元

**示例**：

```c++
int main()
{
	//1、字符型变量创建方式
	char ch = 'a';
	cout << ch << endl;

	//2、字符型变量所占内存大小
	cout << "字符型所占内存大小为 "<< sizeof(char) << endl;

	//3、字符型变量常见错误
	// char ch2 = "b"; //创建字符型变量时，要用单引号；
	// char ch3 = 'fdsaf';  //创建字符型变量时，单引号内只能有一个字符；

	//4、字符型变量对应ascii码
	//a - 97
	//A - 65
	cout << (int)ch << endl;
	

	system("pause");

	return 0;
}
```

**ASCII表**

![](C:\Users\48228\Downloads\20210507174304591.png)

ASCII码大致由一下**两个部分**组成:

* ASCII 非打印控制字符：ASCII表上的数字 **0-31** 分配给了控制字符，用于控制像打印机等一些外围设备。
* ASCII打印字符：数字 **32-126** 分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。

### 2.5 转义字符

**作用**：用于表示一些不能显示出来的ASCII字符

现阶段我们常用的转义字符右：`\n  \\  \t`

```c++
int main()
{
	//转义字符
	//换行符  \n
	cout << "hello world" << endl;
	cout << "hello world\n";

	//反斜杠  
	cout << "\\" << endl;

	//水平制表符  \t 作用可以整齐输出数据
	cout << "aaaa\ttian" <<endl;
	cout << "aaaaa\ttian" <<endl;
	cout << "aaa\ttian" <<endl;
	cout << "a\ttian" <<endl;

	system("pause");

	return 0;
}

```



### 2.6 字符串型

**作用**：用于表示一串字符串

**两种风格**

1. C风格字符串：`char 变量名[] = "字符串值"`

   示例：

   ```c++
   int main(){
   	
   	char str1[] = "hello world";
   	cout << str1 <<endl;
           
       system("pause");
       
       return 0;
   }
   ```

   > 注意:C风格的字符串要用双引括号括起来

2. C++风格字符串：`string 变量名 = "字符串值"`

   示例：

   ```c++
   int main(){
   	
   	//2、C++风格字符串
   	//要包含一个头文件   #incloud<string>
   	string str2 = "hello world";
   	cout << str2 << endl;
   	system("pause");
           
       system("pause");
       
       return 0;
   }
   ```

   > 注意：C++风格字符串，需要加入头文件 #include<string>



### 2.7布尔型 bool

**作用**：布尔数据类型代表真或假的值

bool类型只有两个值：

* true ---真（本质是1）
* false ---假（本质是0）

**bool类型占1个字节大小**

**示例**：

```
int main()
{
	//1、创建bool数据类型
	bool flag = true;   //true代表真
	cout << flag << endl;
	
	flag = false;   //false代表假
	cout << flag << endl;
	//本质 1代表真 0代表假

	//2、查看bool类型所占内存空间
	cout << "bool类型所占内存空间："<< sizeof(bool) <<endl;

	system("pause");

	return 0;
}
```



### 2.8 数据的输入

**作用：用于从键盘获取数据**

**关键字**：cin

**语法**：`cin >> 变量`

**示例**：

```c++
int main()
{
	//1、整型
//	int a = 0;
//	cout << "请给整型变量a赋值：" << endl;
//	cin >> a;
//	cout << "整型变量a=" << a << endl;

	//2、浮点型
//	float f = 0.88;
//	cout << "请给浮点型变量a赋值：" << endl;
//	cin >> f;
//	cout << "浮点型变量f=" << f << endl;

	//3、字符型
//	char ch = a;
//	cout << "请给字符型变量ch赋值：" << endl;
//	cin >> ch;
//	cout << "字符型变量=" << ch << endl;

	//4、字符串型
//	string str = "hello";
//	cout << "请给字符串型变量str赋值：" << endl;
//	cin >> str;
//	cout << "字符串str= " << str <<endl;

	//5、布尔类型
	bool flag = false;
	cout << "请给布尔类型flag赋值：" << flag << endl;
	cin >> flag;
	cout << "布尔类型变量flag=" << flag << endl;

	system("pause");

	return 0;
}
```



## 3 运算符

**作用**：用于执行代码的运算

主要讲解以下几类运算符：

| 运算符类型 | 作用                                   |
| ---------- | -------------------------------------- |
| 算术运算符 | 用于处理四则运算                       |
| 赋值运算符 | 用于将表达式的值赋给变量               |
| 比较运算符 | 用于表达式的比较，并返回一个真值或假值 |
| 逻辑运算符 | 用于根据表达式的值返回真值或假值       |



### 3.1 算术运算符

**作用**：用于处理四则运算

算术运算符包括以下符号：

| 运算符 | 术语     | 示例         | 结果       |
| ------ | -------- | ------------ | ---------- |
| +      | 正号     | +3           | 3          |
| -      | 负号     | -3           | -3         |
| +      | 加号     | 10+5         | 15         |
| -      | 减号     | 10-5         | 5          |
| *      | 乘       | 10*5         | 50         |
| /      | 除       | 10/5         | 2          |
| %      | 取模     | 10%3         | 1          |
| ++     | 前置递增 | a=2；b=++a； | a=3，b=3； |
| ++     | 后置递增 | a=2；b=a++； | a=3，b=2； |
| --     | 前置递减 | a=2；b=--a； | a=1，b=1； |
| --     | 后置递减 | a=2；b=a--； | a=1，b=2； |

**示例**：

```c++
//四则运算
int main()
{
	//加减乘除
	int a1 = 10;
	int b1 = 3;
	cout << a1 + b1 << endl;
	cout << a1 - b1 << endl;
	cout << a1 * b1 << endl;
	cout << a1 / b1 << endl;  //两个整数相除 还是整数，将小数部分去除。

	int a2 = 10;
	int b2 = 20;
	cout << a2 / b2 << endl;

	int a3 = 10;
	int b3 = 0;
//	cout << a3 / b3 <<endl;  //错误！两个数相除，除数不可以为0的

	//两个小数可以相除吗？ 可以
	double d1 = 0.5;
	double d2 = 0.03;
	cout << d1 / d2 << endl; //运算的结果也可以是小数



	system("pause");
	return 0;

}
```

> 总结：在除法运算中，除数不能为0



**示例**

```c++
//取模
int main()
{
	//取模运算本质  就是求余数；
	int a1 = 10;
	int b1 = 3;
	cout << a1 % b1 << endl;

	int a2 = 10;
	int b2 = 20;
	cout << a2 % b2 << endl;


	//两个小数是不可以做取模运算的
	double d1 = 2.13;
	double d2 = 0.2;
//	cout << d1 % d2 << endl;

	system("pause");
	return 0;

}
```

> 总结：只有整型变量可以进行取模运算。



**示例**：

```c++
#include<iostream>
using namespace std;

int main()
{
	//1、前置递增
	int a = 10;
	++a;  //让变量 +1
	cout << "a = " << a <<endl;

	//2、后置递增
	int b = 10;
	b++;  //让变量 +1
	cout << "b = "<< b <<endl;


	//3、前置和后置的区别
	//前置递增 先让变量加1 然后进行表达式运算
	int a2 = 10;
	int b2 = ++a2 * 10;
	cout << "a2 = " << a2 << endl;
	cout << "b2 = " << b2 << endl;

	//后置递增 先进行表达式运算 后让变量加1
	int a3 = 10;
	int b3 = a3++ * 10;
	cout << "a3 = " << a3 << endl;
	cout << "b3 = " << b3 << endl;

	system("pause");
	return 0;

}
```



### 3.2 赋值运算符

**作用**：用于将表达式的值赋给变量

赋值运算符宝库以下几个符号：

| 运算符 | 术语   | 示例      | 结果           |
| ------ | ------ | --------- | -------------- |
| =      | 赋值   | a=2；b=3  | a = 2；b = 4； |
| +=     | 加等于 | a=0；a+=2 | a=2；          |
| -=     | 减等于 | a=5；a-=3 | a=2            |
| *=     | 乘等于 | a=2；a*=2 | a=4            |
| /=     | 除等于 | a=4；a/=2 | a=2            |
| %=     | 等于   | a=3，a%2  | a=1。          |

## 4 条件判断语句

### 4.1 判断条件

简单 if 语句：

```c++
if(表达式)
	语句
```



if...else 判断语句

```c++
if(表达式)
	语句1；
else
	语句2；
```

相当于 如果。。。那么。。。



else if 判断语句

```
if(表达式1)
	语句 1；
else if(表达式2)
	语句 2；
else if(表达式3)
	语句 3；
else if(表达式4)
	语句 4；
	...
else if(表达式,m)
	语句 m；
else 
	语句 n;
```

![](https://zt0729-picture-bed.oss-cn-beijing.aliyuncs.com/ii/5be33462701845a2d74e72a7fdc6a299.jpeg)



条件运算符（ ?  : ）

`? :` 是一个三目运算符，其构成的表达式能像 `if...else` 一样完成判断。

```c++
表达式a ? 表达式b(真执行) : 表达式c(假执行)；
```

这个条件运算符可以嵌套，例如

```c++
表达式a ? (表达式b ? 表达式c : 表达式 d) : 表达式 e;
```



`switch`  语句

```c++
switch(表达式)
{
	cese 常量表达式1:
	语句1;
	break;
	cese 常量表达式2:
	语句1;
	break;
	...
	cese 常量表达式n:
	语句n;
	break;
	default;
	语句 n+1;
}

```





### 4.2 循环语句

`while` 循环

`while` 循环语句的一般形式如下：

```c++
while(表达式)
	语句;
```



`do ... while` 循环

`do ... while` 循环语句的一般形式如下：

```c++
do
	语句
while(表达式);
```



`for` 循环

for 循环语句的一般格式如下：

```c++
for (表达式1;表达式2;表达式3)
	语句
	
// 表达式 1：该表达式通常是一个赋值表达式，负责设置循环的起始值，也就是给控制循环的变量赋初值。
// 表达式 2：该表达式通常是一个关系表达式，用控制循环的变量和循环变量允许的范围值进行比较。
// 表达式 3：该表达式通常是一个赋值表达式，对控制循环的变量进行增大或减小。
// 语句：循环体，一般为复合语句。
```



`break` 语句

可以用 `break` 语句跳出当先循环体，从而中断当前循环。

> 如果遇到循环嵌套的情况，break 语句只会使程序流程跳出包含它的最内层循环结构，即只跳出一层循环。

`break` 语句的形式：

![break形式](https://zt0729-picture-bed.oss-cn-beijing.aliyuncs.com/ii/break%E5%BD%A2%E5%BC%8F.jpg)



`continue` 语句

`continue` 语句是针对 `break` 语句的补充，continue 不是立刻跳出循环体，而是跳过本次循环结束前的语句，回到循环的条件测试部分，重新开始执行测试部分。



## 5 函数

### 5.1 函数的定义

定义一个函数的一般形式如下：

```c++
类型标识符 函数名(形式参数列表)
{
	变量的声明
	语句
}

//类型标识符：用来标识函数的返回值类型，通过返回值可以判断函数的执行情况，也可以获取想要的数据。函数标识符可以是整型、字符型、指针型、或对象的数据类型。

//形式参数列表是由各种变量类型变量组成的列表，各参数之间用逗号隔开。在进行函数调用时，通过主调函数的实际参数列表对变量进行赋值。
	*形式参数列表可以为空。

```



### 5.2 函数的声明

调用一个函数前，必须先声明函数的返回类型和参数类型。例如：

```c++
int Setlndex(int i)
```

函数声明也称为函数原型，函数声明时可以省略变量名。例如：

```c++
int Setlndex(int)
```



### 5.3 函数参数及返回值

#### 返回值

* 返回值是指函数调用之后，执行函数体中的程序段取得的并返回给主调函数的值，函数的返回值通过 `return` 语句返回给主函数；
* `return` 语句的一般形式如下：

```
return (表达式);
```

* 返回值说明：
  1. 函数返回值的类型和函数定义中类型表示应保持一致，如果两者不一致，则以函数类型为准，自动进行函数转换。
  2. 如果 函数值为整型，在函数定义时可以省去类型标识符。
  3. 在函数中可以允许有多个`return` 语句，但每次调用只能有一个被执行，因此只能返回一个函数值；
  4. 不需要返回函数值的函数，可以明确定义为”空类型，类型标识符为 `void`。
  5. 类型标识符为 `void` 的函数不能进行赋值运算及值传递。

#### 形参与实参

* 函数定义时：
  1. 如果参数列表为空，说明函数时无参函数；
  2. 如果不为空，则称为带参函数。

* 带参函数在函数声明和定义时被称为形式参数，简称形参
* 在函数被调用时被赋予具体值，具体的值被称为实际参数，简称实参。
* 形参与实参的区别：
  1. 定义函数时指定的形参，在为出现函数调用前，并不占用内存中的存储单元。只有在发生函数调用时，函数的形参才被分配内存单元。在调用结束后，其所占的内存单元将被释放
  2. 实参是确定的值。在调用时将实参的值赋给形参，如果形参是指针类型，就将地址值传递给形参。
  3. 形参和实参的类型相同。
  4. 实参与形参之间是单相传递，只能由实参传递给形参，而不能由形参传回给实参。

#### 默认参数

调用带参函数时，如果经常需要传递同一个值到调用函数，不妨在定义函数时为参数设置一个默认值。



### 5.4 函数调用

* 声明函数后需要在源代码中调用该函数，整个函数的调用过程称为函数调用。标准 C++ 是一种强制类型检查的语言，在调用函数前必须吧函数的参数类型和返回值类型告知编译器。
* 函数调用的说明如下：
  1. 被调用的函数必须是已经存在的函数（是库函数或用户自己定义的函数）。
  2. 如果使用库函数，还需要将库函数对应的头文件引入，这需要使用预编译指令 `#include`
  3. 如果使用用户自定义函数，一般还应在主调函数中对被掉函数做声明

#### 传值调用

* 主调函数 和 被调函数之间存在着数据传递关系。换句话说，主调函数将实参数值复制到调用函数的形参处，这种调用方式称为传值调用。
* 如果传递的实参是结构体对象，值传递方式的效率是底下的，可以通过传递指针或使用变量的引用来替换传值调用。

### 5.5 变量的作用域

* 根据变量声明的位置，可以将变量分为==局部变量==和==全局变量==。
* 在函数体内定义的变量称为==局部变量==
* 在函数体外定义的变量称为==全局变量==

> 变量都有它的生命期，全局变量在程序开始时创建并分配空间，在程序结束时释放内存并销毁；局部变量是在函数调用时创建，并在栈中分配内存，在函数调用结束后摧毁并释放。



### 5.6 重载函数

* 定义同名的变量，程序会编译出错；定义同名的函数，也会带来冲突的问题。C++ 中使用了名称重组技术，通过函数的阐述类型来识别函数。所谓重载函数，就是指多个函数具有相同的函数名，而参数类型或参数个数不同。函数调用时，编译器以参数类型及个数来区分调用哪个函数。

### 5.7 变量的存储类型

#### 1. auto 变量

* `auto`（自动）变量是 C++ 语言程序中，默认的存储类型。函数内未加存储类型说明的变量均视为 auto 变量，也就是说，`auto` 变量可省去关键字 `auto`。
* `auto` 变量具有以下特点：
  1. `auto` 变量的作用域仅限于定义该变量的个体内。在函数中定义的 `auto` 变量，只在该函数内有效；在复合语句中定义的 `auto` 变量，只在该复合语句中有效。
  2. `auto` 变量属于动态存储方式，变量分配的内存在栈中，当函数调用结束后，自动变量的值被释放。同样在复合语句中定义的 `auto` 变量。在退出复合语句后也不能再使用，否者将引起错误。
  3. `auto` 变量的作用域和生存期都局限于定义他的个体内（函数或复合语句内），因此不同的个体中允许使用同名的变量而不会混淆。即使在函数内定义的 `auto`变量也可与该函数内部的复合语句中定义的 `auto` 变量同名

#### 2. static 变量

* 在声明变量前加关键字 `static` ，可以将变量声明成`static (常态)`变量。静态局部变量的值在函数调用后不消失，静态全局变量只能在本源文件中使用
* `static` 变量属于静态存储方式，它具有以下特点：
  	1. `static` 变量在函数内定义，在程序退出时释放，即在程序整个运行期间都不释放，也就是说它的生存期为整个源程序。
  	1. `static` 变量作用域与 `auto` 变量相同，在函数内定义的在函数内使用，尽管该变量还继续存在但不能使用。只有再次调用定义它的函数时，才可继续使用
  	1. 编译器会为静态局部变量赋予 0 值

#### 3. register 变量

* 变量的值通常存放在内存中，当需要对一个变量频繁读写时，反复访问内存储器将花费大量的存取时间。为提高效率，C++语言允许将变量声明为`register (寄存器) 变量`，这种变量将局部变量的值存放在 CPU 中的寄存器中，使用时不需要访问内存，而直接从寄存器中读写。`register` 变量的说明符是 `register`
* 对 `register` 变量的说明如下：
  1. `register` 变量属于动态存储方式，凡是采用静态存储方式的量不能定义为`register`
  2. 编译程序会自动决定哪个变量使用寄存器存储。`register` 变量起到程序优化的作用。

#### 4.  extern 变量

* 在一个源文件中定义的变量和函数只能被本文件中的函数调用。一个 C++程序 通常有许多源文件。在使用其他源文件变量时，只需在本源文件中使用 extern 关键字声明这个变量即可。



## 6 数组、指针和引用

### 6.1 一维数组

#### 6.1.1 一维数组的声明

在程序设计中，将同一数据类型的数据按一定形式有序地组织起来，这些有序数据的集合称为数组。一个数组有一个统一的数组名，可以通过数组和下标来唯一确定数组中的元素。

一维数组的声明形式如下：

```c++
数组类型 数组名[常量表达式];

例如：
    int a[10];             //声明一个整型数组，数组有 10 个元素
	char name[128];        //声明一个字符数组，数组有 128 个元素
	float price[20];       //声明一个浮点数组，数组有 20 个元素
```

* 使用一维数组的说明如下：
  1. 数组名的命名规则和变量名相同。
  2. 数组名后面的括号是方括号，方括号内是常量表达式
  3. 常量表达式表示元素的个数，即数组的长度
  4. 定义数组的常量表达式不能是变量，因为数组的大小不能动态地定义

#### 6.1.2 一维数组的引用

引用一维数组元素的一般形式为“数据名[下标]”。

例如：

```c++
int a[10]   //声明数组

则a[0]、a[1]、a[2]、a[3]、a[4]、a[5]、a[6]、a[7]、a[8]、a[9]，是对数组 a 中的10个元素的引用
```

* 引用一维数组元素时，要注意：
  1. 数组元素的下标起始值为 0，而不是1，
  2. a[10] 是不存在的数组元素，引用 a[10] 非法。

#### 6.1.3 一维数组的初始化

数组初始化分为两种：一种是对单个元素逐一赋值，另一种是使用聚合方式赋值。

1. 单一数组元素赋值

   `a[0]=0` 就是对单一数组元素赋值，

2. 聚合方式赋值

   宿主不仅可以逐一对数组元素赋值，还可以通过大括号进行多个元素的赋值。

   ```c++
   int a[12] = {1,2,3,4,5,6,7,8,9,10,11,12}     //
   int b[] = {1,2,3,4,5,6,7,8,9,10,11,12}       //编译器能够获得数组元素个数
   int c[12] = {1,2,3,4,5,6,7}                  //前7个元素被赋值，后面5个元素的值为0
   ```



### 6.2 二维数组

#### 6.2.1 二维数组的声明

二维数组声明的一般形式如下：

```c++
数据类型 数组名[常量表达式 1][常量表达式 2]

例如：
int a[3][4];    //声明具有 3 行 4 列元素的的整型数组
float myarray[4][5]     //声明具有 4 行 5 列元素的浮点数组
```

* 使用二维数组的说明如下：
  1. 数组名的命名规则和变量名相同。
  2. 二维数组有两个下标，所以有两个中括号。
  3. 下标运算符中的整数表达式代表数组每一维的长度，必须是正整数，其积决定了整个数组的长度。
  4. 定义数组的常量表达式不能是变量，因为数组的大小不能动态地定义

#### 6.2.2 二维数组的引用

二维数组的引用形式如下：

```c++
数组名 [下标][下标]
```

#### 6.2.3 二维数组的初始化

二维数组元素初始化的方式和一维数组相同，也分为单个元素逐一赋值和使用聚合方式赋值，例如：

```c++
myArray[0][1] = 12;
int a[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12}
```

二维数组中元素排列的顺序是按行存放的，即在内存中先顺序存放第一行的元素，再存放第二行的元素。

### 6.3 字符数组

用于存放字符数据的数组是字符数组。字符数组中，一个元素存放一个字符。字符数组是具有数组的共同属性。

1. 声明一个字符数组

   ```c++
   char pWord[11];
   ```

2. 字符数组赋值方式

   * 数组元素单一赋值

     ```C++
     pWord[0]='H';
     ```

   * 聚合方式赋值

     ```c++
     char pWord[11] = {'h';'e'}
     ```

3. 字符数组的说明

   * 聚合方式赋值只能在数组声明时使用
   * 字符数组不能给字符数组赋值

4. 字符串和字符串结束符

   * 字符数组常用于存储字符串，此时要连同字符串结束符一起保存。

   * 可以使用字符串为字符数组赋值例如：

     ```c++
     char a[] = "HELLO WORLD";
     
     等同于
     
     char a[] = "HELLO WORLD\0"
     ```

5. 字符串处理函数

   1. strcat 函数

      字符串连接函数 `strcat` 的语法格式如下：

      ```c++
      strcat(字符数组名1，字符数组名2)
          
      // strcat 函数把字符数组2中的字符串连接到字符数组1中字符串的后面，并删去源字符数组1中的字符串结束符 /0
      ```

   2. strcpy函数

      字符串复制函数 `strcpy` 中的语法如下：

      ```
      strcpy(字符数组1，字符数组2)
      ```

      `strcpy` 函数把字符数组 2 中的字符串复制到字符数组 1 中，字符串结束符 ` \0` 也一同复制。

   3. strcmp 函数

      字符串比较函数 `strcmp` 的语法格式如下：

      ```c++
      strcmp(字符数组1, 字符数组2)
      ```

      `strcmp` 函数按照 ASCII 码顺序比较两个数组中的字符串，并返回结果

      * 字符串 1 = 字符串 2，返回值为0。
      * 字符串 1 > 字符串 2，返回值为一整数。
      * 字符串 1 > 字符串 2，返回值为一负数。

   4. strlen 函数

      测字符串长度函数 `strlen` 的语法格式如下：

      ```c++
      strlen(字符数组名)
      ```

      `strlen` 函数测字符串的实际长度（不含字符串结束符 `\0`）,函数返回值为字符串的实际长度。

### 6.4 指针

#### 6.4.1 变量与指针

地址可以形象地称为指针，意思是通过指针能找到内存单元。一个变量的地址称为该变量的指针。如果有一个变量专门用来存放另一个变量的地址，他就是==指针变量==。在 C++ 语言中有专门用来存放内存单元地址的变量类型，就是指针类型。

指针是一种数据类型，同上所说的指针就是指针变量，他就是专门用来存放地址的变量，而变量的指针主要是指变量在内存中的地址。变量的地址在编写代码时无法获取，只有在程序运行时得到。

1. 指针的声明

   声明指针的一般形式如下：

   ```c++
   数据类型标识符 *指针变量名
       
   例如：
       int *p_ipoint;   //声明一个整型指针
   	int *a,*b        //声明两个浮点指针
   ```

2. 指针的赋值

   指针可以在声明时进行初始化赋值，也可以后期再赋值。

   在初始化时赋值：

   ```c++
   int = 1;
   int *p_iPoint = &1;
   ```

   在后期赋值：

   ```c++
   int i = 100;
   p_iPoint = &i
   ```

   * 通过变量名访问一个变量是直接的，而通过指针访问一个变量是间接的。

3. 关于指针使用的说明

   1. ==指针变量名是 `p`，而不是 `*p`，`p = &i` 的意思是取变量 i 的地址赋给指针变量 p。==
   2. 指针变量不能直接赋值
   3. 不能将 `*p` 当做变量来使用。

#### 6.4.2 指针运算符和取地址运算符

1. 指针运算符 和 取地址运算符 简介

   `*` 和 `&` 是两个运算符，`*` 是指针运算符，`&` 是取地址运算符

2. 指针运算符和取地址运算符的说明

   声明并初始化指针变量时，同时会用到 `*` 和 `&` 两个运算符，例如

   ```c++
   int *p = &a;
   
   该语句等同于
       
   int *(p=&a);
   ```

3. `&*p` 和 `*&a` 的区别

   `&` 和 `*` 的运算符优先级相同，按自右而左的方向结合。因此，`&*p` 是先计算 `*` 运算，`*p` 相当于变量 a；再进行 `&` 运算，`&*p` 就相当于取 `a` 的地址。`*&a` 是先计算 `&` 运算符，`&a`就是取变量 `a` 的地址，然后计算 `*` 运算，`*&a` 相当于取变量 `a` 所在地址的值，实际就是变量 `a`

#### 6.4.3 指针运算

指针变量存储的是地址，对指针做运算就等于对地址做运算。

指针进行加 1 运算，其地址并没有加 1 ，而是增加了 4，这和声明指针的类型有关。

定义指针变量时，必须指定一个数据类型。指针变量的数据类型用来指定该指针变量所指向数据的类型。

####  6.4.4 指向空的指针与空类型指针

指针可以指向任何数据类型，包括空类型（`void`）；

```c++
void *p;
```

空类型指针可以接受任何类型的数据，可以将其强制转化为所对应的数据类型。

#### 6.4.5 指向常量的指针与指针常量

* `int const* p = &i ` 与 `const int * p = &i  ` 等价 ，都表示 `*p` 的值不能改变，而 `p`（即地址）是可以改变的；

* `int *const p = &i ` 是`*P` 的值能改变，但 `p` （即地址）不能改变。
* `const int *const p = &i` 两者值和地址都不能改变。

### 7.5 指针和数组

#### 7.5.1指针和一维数组

如果把数组的地址赋值给指针变量，就可以通过指针变量引用数组。引用数组元素有两种方法：下标法和指针法。

通过指针法引用数组，要先声明一个数值





### 7.6 指针在函数中的作用

1. 传递地址





### 7.8 引用



## 8. 函数







### 8.7 函数的分文件编写

**作用**：让带吗结构更加清晰

函数分文件编写一般有 4 个步骤：

1. 创建后缀名为`.h` 的头文件
2. 创建后缀名为 `.cpp` 的源文件
3. 在头文件写函数的声明
4. 在源文件中写函数的定义
5. 





















## 9. 结构体

### 9.1 结构体基本概念

结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型



### 9,2 结构体定义和使用

**语法：** `struct 结构体名 { 结构体成员列表 };`

通过结构体创建变量的方式有三种：

* struct 结构体名 变量名
* struct 结构体名 变量名 ={成员1值，成员2值，成员3值。。。。。。。}
* 定义结构体时顺便创建变量

**示例**：

```c++
int main()
{
	struct student
	{
		//成员列表
		//姓名
		string name;
		//年龄
		int age;
		//分数
		int score;
	}s3;
	//2、通过学生类型创建具体属性

	//2.1 struct student s1
	//给s1属性赋值，通 . 过访问结构体变量中的属性
	//创建结构体变量时 strcut 关键字可以省略
	struct student s1;
	s1.name = "张三";
	s1.age = 18;
	s1.score = 99;
	cout << " 姓名： " << s1.name << " 年龄：" << s1.age << " 分数：" << s1.score << endl;

	//2.2 struct student s2 = {...}
	struct student s2 = {"李四",18,99};
	cout << " 姓名： " << s2.name << " 年龄：" << s2.age << " 分数：" << s2.score << endl;
	
	//2.3 在定义结构体时顺便创建结构体变量
	s3.name = "王五";
	s3.age = 22;
	s3.score = 30;
	cout << " 姓名： " << s3.name << " 年龄：" << s3.age << " 分数：" << s3.score << endl;

	system("pause");
	return 0;
}
```

> 总结1：定义结构体时的关键字 struct，不可以省略

> 总结2：创建结构体变量时，关键字 struct 可以省略

> 总结3：==结构体变量利用操作符 ` "." ` 访问成员==

### 9.3 结构体数组 

**作用**：将自定义的结构体放入到数组中方便维护

**语法**：`struct  结构体名  数组名[元素个数] = {{}, {}, {}, ... {}}

**示例**：

```c++
struct student
{
	string name;
	int age;
	int score;
};



int main()
{
//2、创建结构体数组
	struct student stuarray[3] = 
	{
		{"张三",18,29},
		{"李四",22,22},
		{"王五",20,23}
	};

//3、给结构体数组中元素赋值
	stuarray[2].name = "赵六";

//4、遍历结构体数组
	for (int i = 0;i<3;i++)
	{
		cout << "姓名： " << stuarray[i].name 
			 << " 年龄：" << stuarray[i].age 
			 << " 成绩：" << stuarray[i].score 
			 << endl;
	}

	system("pause");
	return 0;
}
```



### 9.4 结构体指针

**作用**：通过指针访问结构体中的成员

* 利用操作符 `->` 可以通过结构体指针访问结构体属性



**示例**：

```c++
//结构体指针

//定义学生结构体
struct student
{
	string name; //姓名
	int age;     //年龄
	int score;   //分数
};



int main()
{
	//1、创建学生结构体变量
	struct student s = {"张三",18,23};
	
	//2、通过指针指向结构体变量
	struct student *p = &s;

	//3、指针访问结构体
	//通过结构体指针 访问结构体中的属性，需要利用"->"
	cout << "姓名："<< p->name << endl;
	system("pause");
	return 0;
}
```



 ### 9.5 结构体嵌套结构体

**作用**：结构体中的成员可以使另一个结构体。

**例如**：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体

**示例**：

```c++
struct teacher
{
	int id;
	string name;
	int age;
	struct student stu;
};


int main()
{
	teacher t;
	t.id = 12312;
	t.name = "王二";
	t.age = 84;
	t.stu.name = "小花";
	t.stu.age = 55;
	t.stu.score = 55;

	//3、指针访问结构体
	//通过结构体指针 访问结构体中的属性，需要利用"->"
	cout << "老师姓名："<< t.name << "老师编号：" << t.id << "老师年龄：" << t.age << "老师辅导的学生" << t.stu.name <<endl;

	system("pause");
	return 0;
}
```



### 9.6 结构体做函数参数

**作用**：将结构体作为参数向函数中传递

传递方式有两种：

* 值传递
* 地址传递

**示例**：

```c++
//结构体指针

//定义学生结构体
struct student
{
	string name; //姓名
	int age;     //年龄
	int score;   //分数
};

//值传递
void printstudent1(struct student s)
{
	cout << "子函数1打印 学生姓名：" << s.name << "学生年龄" << s.age << "学生成绩" << s.score <<endl;
};

void printstudent2(struct student *p)
{
	cout << "子函数2打印 学生姓名：" << p->name << "学生年龄" << p->age << "学生成绩" << p->score <<endl;
};

int main()
{
	//结构体做函数参数
	//将学生传入到一个参数中，打印学生身上的所有信息。

	struct student s;
	s.name = "张三";
	s.age = 18;
	s.score = 99;

	cout << "在main函数中打印的结果 姓名：" << s.name << "年龄：" << s.age << "成绩：" << s.score <<endl; 

	printstudent1(s);
	printstudent2(&s);
	system("pause");
	return 0;
}
```





### 9.7 结构体中 const 使用场景

**作用**：用 `const` 来防止误操作。

**示例**：

```c++
// const 的使用场景

//定义学生结构体
struct student
{
	string name; //姓名
	int age;     //年龄
	int score;   //分数
};

//将函数中的形参改为指针，可以减少内存空间。而且不会复制新的副本出来
void printS(const student *s)  //加 const 防止误操作。
{
	cout << "姓名：" << s->name << "年龄：" << s->age << "成绩：" << s->score <<endl;
};




int main()
{
	//结构体做函数参数
	//将学生传入到一个参数中，打印学生身上的所有信息。

	struct student s;
	s.name = "张三";
	s.age = 18;
	s.score = 99;

	
	printS(&s);
	
	cout << "张三年龄：" << s.age << endl;
	system("pause");
	return 0;
}
```


